// Simulation code for testZC generated by the OpenModelica Compiler 1.7.0 (r8920).

#include "modelica.h"
#include "assert.h"
#include "string.h"
#include "simulation_runtime.h"

#include "testZC_functions.h"

#ifdef __cplusplus
extern "C" {
#endif
#include "Print_ext.h"
#ifdef __cplusplus
}
#endif
#include "testZC_functions.cpp"
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif
#define NHELP 4
#define NG 2 // number of zero crossings
#define NG_SAM 0 // number of zero crossings that are samples
#define NX 2  // number of states
#define NY 1  // number of real variables
#define NA 0  // number of alias variables
#define NP 0 // number of parameters
#define NO 0 // number of outputvar on topmodel
#define NI 0 // number of inputvar on topmodel
#define NR 2 // number of residuals for initialialization function
#define NEXT 0 // number of external objects
#define NFUNC 2 // number of functions used by the simulation
#define MAXORD 5
#define NYSTR 0 // number of alg. string variables
#define NASTR 0 // number of alias string variables
#define NPSTR 0 // number of alg. string variables
#define NYINT 0 // number of alg. int variables
#define NAINT 0 // number of alias int variables
#define NPINT 0 // number of alg. int variables
#define NYBOOL 0 // number of alg. bool variables
#define NABOOL 0 // number of alias bool variables
#define NPBOOL 0 // number of alg. bool variables
#define NJACVARS 0 // number of jacobian variables

static DATA* localData = 0;
#define time localData->timeValue
#define $P$old$Ptime localData->oldTime
#define $P$current_step_size globalData->current_stepsize

#ifndef _OMC_QSS
extern "C" { // adrpo: this is needed for Visual C++ compilation to work!
  const char *model_name="testZC";
  const char *model_fileprefix="testZC";
  const char *model_dir="";
}
#endif

// we need to access the inline define that we compiled the simulation with
// from the simulation runtime.
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;

const struct omc_varInfo state_names[2] = {
  {1000,"x","",{"TestExt.mo",2,2,2,19,0}},
  {1001,"y","",{"TestExt.mo",3,2,3,19,0}}
};
#define $Px__varInfo state_names[0]
#define $Py__varInfo state_names[1]
const struct omc_varInfo derivative_names[2] = {
  {1002,"der(x)","",{"TestExt.mo",2,2,2,19,0}},
  {1003,"der(y)","",{"TestExt.mo",3,2,3,19,0}}
};
#define $P$DER$Px__varInfo derivative_names[0]
#define $P$DER$Py__varInfo derivative_names[1]
const struct omc_varInfo algvars_names[1] = {
  {1004,"s","",{"TestExt.mo",4,2,4,17,0}}
};
#define $Ps__varInfo algvars_names[0]
const struct omc_varInfo param_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo int_alg_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo int_param_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo int_alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo bool_alg_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo bool_param_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo bool_alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo string_alg_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo string_param_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo string_alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo jacobian_names[1] = {{-1,"","",omc_dummyFileInfo}};
struct omc_functionInfo function_names[2] = {
  {1005,"Init",{"TestExt.mo",32,1,35,9,0}},
  {1006,"Print",{"TestExt.mo",24,1,30,10,0}}
};

#define $Px localData->states[0]
#define $P$old$Px localData->states_old[0]
#define $P$old2$Px localData->states_old2[0]
#define $Py localData->states[1]
#define $P$old$Py localData->states_old[1]
#define $P$old2$Py localData->states_old2[1]
#define $P$DER$Px localData->statesDerivatives[0]
#define $P$old$P$DER$Px localData->statesDerivatives_old[0]
#define $P$old2$P$DER$Px localData->statesDerivatives_old2[0]
#define $P$DER$Py localData->statesDerivatives[1]
#define $P$old$P$DER$Py localData->statesDerivatives_old[1]
#define $P$old2$P$DER$Py localData->statesDerivatives_old2[1]
#define $Ps localData->algebraics[0]
#define $P$old$Ps localData->algebraics_old[0]
#define $P$old2$Ps localData->algebraics_old2[0]
#define Init_index 0
#define Print_index 1

void init_Alias(DATA* data)
{
  sim_DATA_REAL_ALIAS omc__realAlias[1] = {{0,false,-1}};
  sim_DATA_INT_ALIAS omc__intAlias[1] = {{0,false,-1}};
  sim_DATA_BOOL_ALIAS omc__boolAlias[1] = {{0,false,-1}};
  sim_DATA_STRING_ALIAS omc__stringAlias[1] = {{0,false,-1}};
if (data->nAlias)
  memcpy(data->realAlias,omc__realAlias,sizeof(DATA_REAL_ALIAS)*data->nAlias);
if (data->intVariables.nAlias)
  memcpy(data->intVariables.alias,omc__intAlias,sizeof(DATA_INT_ALIAS)*data->intVariables.nAlias);
if (data->boolVariables.nAlias)
  memcpy(data->boolVariables.alias,omc__boolAlias,sizeof(DATA_BOOL_ALIAS)*data->boolVariables.nAlias);
if (data->stringVariables.nAlias)
  memcpy(data->stringVariables.alias,omc__stringAlias,sizeof(DATA_STRING_ALIAS)*data->stringVariables.nAlias);
};

static char init_fixed[NX+NX+NY+NYINT+NYBOOL+NP+NPINT+NPBOOL] = {
  1 /* x */,
  1 /* y */,
  1 /* der(x) */,
  1 /* der(y) */,
  0 /* s */
};

char var_attr[NX+NY+NYINT+NYBOOL+NYSTR+NP+NPINT+NPBOOL+NPSTR] = {
  1+0 /* x */,
  1+0 /* y */,
  1+16 /* s */
};

const int nEquation = 5;
const struct omc_equationInfo equation_info[5] = {
  {1007,"SES_ALGORITHM 0",0,NULL},
  {1008,"SES_SIMPLE_ASSIGN 1",1,&$P$DER$Py__varInfo},
  {1009,"SES_ALGORITHM 2",0,NULL},
  {1010,"SES_SIMPLE_ASSIGN 3",1,&$P$DER$Px__varInfo},
  {1011,"SES_ALGORITHM 4",0,NULL}
};
const int n_omc_equationInfo_reverse_prof_index = 0;
const int omc_equationInfo_reverse_prof_index[] = {
  
};

const char* getNameReal(double* ptr)
{
  if (&$Px == ptr) return state_names[0].name;
  if (&$Py == ptr) return state_names[1].name;
  if (&$P$DER$Px == ptr) return derivative_names[0].name;
  if (&$P$DER$Py == ptr) return derivative_names[1].name;
  if (&$Ps == ptr) return algvars_names[0].name;
  return "";
}

const char* getNameInt(modelica_integer* ptr)
{
  return "";
}

const char* getNameBool(modelica_boolean* ptr)
{
  return "";
}

const char* getNameString(const char** ptr)
{
  return "";
}

void setLocalData(DATA* data)
{
  localData = data;
  init_Alias(data);
}

DATA* initializeDataStruc()
{
  DATA* returnData = (DATA*)malloc(sizeof(DATA));

  if(!returnData) //error check
    return 0;

  memset(returnData,0,sizeof(DATA));
  returnData->nStates = NX;
  returnData->nAlgebraic = NY;
  returnData->nAlias = NA;
  returnData->nParameters = NP;
  returnData->nInputVars = NI;
  returnData->nOutputVars = NO;
  returnData->nFunctions = NFUNC;
  returnData->nEquations = nEquation;
  returnData->nProfileBlocks = n_omc_equationInfo_reverse_prof_index;
  returnData->nZeroCrossing = NG;
  returnData->nRawSamples = NG_SAM;
  returnData->nInitialResiduals = NR;
  returnData->nHelpVars = NHELP;
  returnData->stringVariables.nParameters = NPSTR;
  returnData->stringVariables.nAlgebraic = NYSTR;
  returnData->stringVariables.nAlias = NASTR;
  returnData->intVariables.nParameters = NPINT;
  returnData->intVariables.nAlgebraic = NYINT;
  returnData->intVariables.nAlias = NAINT;
  returnData->boolVariables.nParameters = NPBOOL;
  returnData->boolVariables.nAlgebraic = NYBOOL;
  returnData->boolVariables.nAlias = NABOOL;
  returnData->nJacobianvars = NJACVARS;

  if (returnData->nStates) {
    returnData->states = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nStates);
    returnData->states_old = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->states_old2 = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->states&&returnData->states_old&&returnData->states_old2);
    memset(returnData->states,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesFilterOutput,0,sizeof(modelica_boolean)*returnData->nStates);
    memset(returnData->states_old,0,sizeof(double)*returnData->nStates);
    memset(returnData->states_old2,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->states = 0;
    returnData->statesFilterOutput = 0;
    returnData->states_old = 0;
    returnData->states_old2 = 0;
  }

  if (returnData->nStates) {
    returnData->statesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesDerivativesFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nStates);
    returnData->statesDerivatives_old = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesDerivatives_old2 = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesDerivativesBackup = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->statesDerivatives&&returnData->statesDerivatives_old&&returnData->statesDerivatives_old2&&returnData->statesDerivativesBackup);
    memset(returnData->statesDerivatives,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesDerivativesFilterOutput,0,sizeof(modelica_boolean)*returnData->nStates);
    memset(returnData->statesDerivatives_old,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesDerivatives_old2,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesDerivativesBackup,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->statesDerivatives = 0;
    returnData->statesDerivativesFilterOutput = 0;
    returnData->statesDerivatives_old = 0;
    returnData->statesDerivatives_old2 = 0;
    returnData->statesDerivativesBackup = 0;
  }

  if (returnData->nHelpVars) {
    returnData->helpVars = (double*) malloc(sizeof(double)*returnData->nHelpVars);
    assert(returnData->helpVars);
    memset(returnData->helpVars,0,sizeof(double)*returnData->nHelpVars);
  } else {
    returnData->helpVars = 0;
  }

  if (returnData->nAlgebraic) {
    returnData->algebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->algebraicsFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nAlgebraic);
    returnData->algebraics_old = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->algebraics_old2 = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    assert(returnData->algebraics&&returnData->algebraics_old&&returnData->algebraics_old2);
    memset(returnData->algebraics,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->algebraicsFilterOutput,0,sizeof(modelica_boolean)*returnData->nAlgebraic);
    memset(returnData->algebraics_old,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->algebraics_old2,0,sizeof(double)*returnData->nAlgebraic);
  } else {
    returnData->algebraics = 0;
    returnData->algebraicsFilterOutput = 0;
    returnData->algebraics_old = 0;
    returnData->algebraics_old2 = 0;
  }

  if (returnData->stringVariables.nAlgebraic) {
    returnData->stringVariables.algebraics = (const char**)malloc(sizeof(char*)*returnData->stringVariables.nAlgebraic);
    assert(returnData->stringVariables.algebraics);
    memset(returnData->stringVariables.algebraics,0,sizeof(char*)*returnData->stringVariables.nAlgebraic);
  } else {
    returnData->stringVariables.algebraics=0;
  }

  if (returnData->intVariables.nAlgebraic) {
    returnData->intVariables.algebraics = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    returnData->intVariables.algebraicsFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->intVariables.nAlgebraic);
    returnData->intVariables.algebraics_old = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    returnData->intVariables.algebraics_old2 = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    assert(returnData->intVariables.algebraics&&returnData->intVariables.algebraics_old&&returnData->intVariables.algebraics_old2);
    memset(returnData->intVariables.algebraics,0,sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    memset(returnData->intVariables.algebraicsFilterOutput,0,sizeof(modelica_boolean)*returnData->intVariables.nAlgebraic);
    memset(returnData->intVariables.algebraics_old,0,sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    memset(returnData->intVariables.algebraics_old2,0,sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
  } else {
    returnData->intVariables.algebraics=0;
    returnData->intVariables.algebraicsFilterOutput=0;
    returnData->intVariables.algebraics_old = 0;
    returnData->intVariables.algebraics_old2 = 0;
  }

  if (returnData->boolVariables.nAlgebraic) {
    returnData->boolVariables.algebraics = (modelica_boolean*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    returnData->boolVariables.algebraicsFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    returnData->boolVariables.algebraics_old = (signed char*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    returnData->boolVariables.algebraics_old2 = (signed char*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    assert(returnData->boolVariables.algebraics&&returnData->boolVariables.algebraics_old&&returnData->boolVariables.algebraics_old2);
    memset(returnData->boolVariables.algebraics,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    memset(returnData->boolVariables.algebraicsFilterOutput,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    memset(returnData->boolVariables.algebraics_old,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    memset(returnData->boolVariables.algebraics_old2,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
  } else {
    returnData->boolVariables.algebraics=0;
    returnData->boolVariables.algebraicsFilterOutput=0;
    returnData->boolVariables.algebraics_old = 0;
    returnData->boolVariables.algebraics_old2 = 0;
  }

  if (returnData->nParameters) {
    returnData->parameters = (double*) malloc(sizeof(double)*returnData->nParameters);
    assert(returnData->parameters);
    memset(returnData->parameters,0,sizeof(double)*returnData->nParameters);
  } else {
    returnData->parameters = 0;
  }

  if (returnData->stringVariables.nParameters) {
    returnData->stringVariables.parameters = (const char**)malloc(sizeof(char*)*returnData->stringVariables.nParameters);
      assert(returnData->stringVariables.parameters);
      memset(returnData->stringVariables.parameters,0,sizeof(char*)*returnData->stringVariables.nParameters);
  } else {
      returnData->stringVariables.parameters=0;
  }

  if (returnData->intVariables.nParameters) {
    returnData->intVariables.parameters = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nParameters);
      assert(returnData->intVariables.parameters);
      memset(returnData->intVariables.parameters,0,sizeof(modelica_integer)*returnData->intVariables.nParameters);
  } else {
      returnData->intVariables.parameters=0;
  }

  if (returnData->boolVariables.nParameters) {
    returnData->boolVariables.parameters = (modelica_boolean*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nParameters);
      assert(returnData->boolVariables.parameters);
      memset(returnData->boolVariables.parameters,0,sizeof(modelica_boolean)*returnData->boolVariables.nParameters);
  } else {
      returnData->boolVariables.parameters=0;
  }

  if (returnData->nOutputVars) {
    returnData->outputVars = (double*) malloc(sizeof(double)*returnData->nOutputVars);
    assert(returnData->outputVars);
    memset(returnData->outputVars,0,sizeof(double)*returnData->nOutputVars);
  } else {
    returnData->outputVars = 0;
  }

  if (returnData->nInputVars) {
    returnData->inputVars = (double*) malloc(sizeof(double)*returnData->nInputVars);
    assert(returnData->inputVars);
    memset(returnData->inputVars,0,sizeof(double)*returnData->nInputVars);
  } else {
    returnData->inputVars = 0;
  }

  if (returnData->nAlias) {
    returnData->realAlias = (DATA_REAL_ALIAS*) malloc(sizeof(DATA_REAL_ALIAS)*returnData->nAlias);
    assert(returnData->realAlias);
    returnData->aliasFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nAlias);
    assert(returnData->aliasFilterOutput);
    memset(returnData->realAlias,0,sizeof(DATA_REAL_ALIAS)*returnData->nAlias);
    memset(returnData->aliasFilterOutput,0,sizeof(modelica_boolean)*returnData->nAlias);
  } else {
    returnData->realAlias = 0;
    returnData->aliasFilterOutput = 0;
  }

  if (returnData->intVariables.nAlias) {
    returnData->intVariables.alias = (sim_DATA_INT_ALIAS*) malloc(sizeof(sim_DATA_INT_ALIAS)*returnData->intVariables.nAlias);
    assert(returnData->intVariables.alias);
    returnData->intVariables.aliasFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->intVariables.nAlias);
    assert(returnData->intVariables.aliasFilterOutput);
    memset(returnData->intVariables.alias,0,sizeof(sim_DATA_INT_ALIAS)*returnData->intVariables.nAlias);
    memset(returnData->intVariables.aliasFilterOutput,0,sizeof(modelica_boolean)*returnData->intVariables.nAlias);
  } else {
    returnData->intVariables.alias = 0;
    returnData->intVariables.aliasFilterOutput=0;
  }

  if (returnData->boolVariables.nAlias) {
    returnData->boolVariables.alias = (DATA_BOOL_ALIAS*) malloc(sizeof(DATA_BOOL_ALIAS)*returnData->boolVariables.nAlias);
    assert(returnData->boolVariables.alias);
    returnData->boolVariables.aliasFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlias);
    assert(returnData->boolVariables.aliasFilterOutput);
    memset(returnData->boolVariables.alias,0,sizeof(DATA_BOOL_ALIAS)*returnData->boolVariables.nAlias);
    memset(returnData->boolVariables.aliasFilterOutput,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlias);
  } else {
    returnData->boolVariables.alias = 0;
    returnData->boolVariables.aliasFilterOutput=0;
  }

  if (returnData->stringVariables.nAlias) {
    returnData->stringVariables.alias = (DATA_STRING_ALIAS*) malloc(sizeof(DATA_STRING_ALIAS)*returnData->stringVariables.nAlias);
    assert(returnData->stringVariables.alias);
    memset(returnData->stringVariables.alias,0,sizeof(DATA_STRING_ALIAS)*returnData->stringVariables.nAlias);
  } else {
    returnData->stringVariables.alias = 0;
  }

  if (returnData->nJacobianvars) {
    returnData->jacobianVars = (double*) malloc(sizeof(double)*returnData->nJacobianvars);
    assert(returnData->jacobianVars);
    memset(returnData->jacobianVars,0,sizeof(double)*returnData->nJacobianvars);
  } else {
    returnData->jacobianVars = 0;
  }

  if (returnData->nInitialResiduals) {
    returnData->initialResiduals = (double*) malloc(sizeof(double)*returnData->nInitialResiduals);
    assert(returnData->initialResiduals);
    memset(returnData->initialResiduals,0,sizeof(double)*returnData->nInitialResiduals);
  } else {
    returnData->initialResiduals = 0;
  }

  returnData->initFixed = init_fixed;
  returnData->var_attr = var_attr;
  returnData->modelName = model_name;
  returnData->modelFilePrefix = model_fileprefix;
  returnData->statesNames = state_names;
  returnData->stateDerivativesNames = derivative_names;
  returnData->algebraicsNames = algvars_names;
  returnData->int_alg_names = int_alg_names;
  returnData->bool_alg_names = bool_alg_names;
  returnData->string_alg_names = string_alg_names;
  returnData->parametersNames = param_names;
  returnData->int_param_names = int_param_names;
  returnData->bool_param_names = bool_param_names;
  returnData->string_param_names = string_param_names;
  returnData->alias_names = alias_names;
  returnData->int_alias_names = int_alias_names;
  returnData->bool_alias_names = bool_alias_names;
  returnData->string_alias_names = string_alias_names;
  returnData->jacobian_names = jacobian_names;
  returnData->functionNames = function_names;
  returnData->equationInfo = equation_info;
  returnData->equationInfo_reverse_prof_index = omc_equationInfo_reverse_prof_index;

  if (returnData->nRawSamples) {
    returnData->rawSampleExps = (sample_raw_time*) malloc(sizeof(sample_raw_time)*returnData->nRawSamples);
    assert(returnData->rawSampleExps);
    memset(returnData->rawSampleExps,0,sizeof(sample_raw_time)*returnData->nRawSamples);
  } else {
    returnData->rawSampleExps = 0;
  }

  if (NEXT) {
    returnData->extObjs = (void**)malloc(sizeof(void*)*NEXT);
    if (!returnData->extObjs) {
      printf("error allocating external objects\n");
      exit(-2);
    }
    memset(returnData->extObjs,0,sizeof(void*)*NEXT);
  } else {
    returnData->extObjs = 0;
  }

  return returnData;
}


/* Has to be performed after _init.txt file has been read */
extern "C" {
}
void callExternalObjectConstructors(DATA* localData) {
  state mem_state;
  mem_state = get_memory_state();
}


extern "C" {
}
void deInitializeDataStruc(DATA* data)
{
  if(!data)
    return;

  if (data->states) {
    free(data->states);
    data->states = 0;
  }

  if (data->states_old) {
    free(data->states_old);
    data->states_old = 0;
  }

  if (data->states_old2) {
    free(data->states_old2);
    data->states_old2 = 0;
  }

  if (data->statesDerivatives) {
    free(data->statesDerivatives);
    data->statesDerivatives = 0;
  }

  if (data->statesDerivatives_old) {
    free(data->statesDerivatives_old);
    data->statesDerivatives_old = 0;
  }

  if (data->statesDerivatives_old2) {
    free(data->statesDerivatives_old2);
    data->statesDerivatives_old2 = 0;
  }

  if (data->algebraics) {
    free(data->algebraics);
    data->algebraics = 0;
  }

  if (data->algebraics_old) {
    free(data->algebraics_old);
    data->algebraics_old = 0;
  }

  if (data->algebraics_old2) {
    free(data->algebraics_old2);
    data->algebraics_old2 = 0;
  }

  if (data->parameters) {
    free(data->parameters);
    data->parameters = 0;
  }

  if (data->inputVars) {
    free(data->inputVars);
    data->inputVars = 0;
  }

  if (data->outputVars) {
    free(data->outputVars);
    data->outputVars = 0;
  }

  if (data->intVariables.algebraics) {
    free(data->intVariables.algebraics);
    data->intVariables.algebraics = 0;
  }

  if (data->intVariables.algebraics_old) {
    free(data->intVariables.algebraics_old);
    data->intVariables.algebraics_old = 0;
  }

  if (data->intVariables.algebraics_old2) {
    free(data->intVariables.algebraics_old2);
    data->intVariables.algebraics_old2 = 0;
  }

  if (data->boolVariables.algebraics) {
    free(data->boolVariables.algebraics);
    data->boolVariables.algebraics = 0;
  }

  if (data->boolVariables.algebraics_old) {
    free(data->boolVariables.algebraics_old);
    data->boolVariables.algebraics_old = 0;
  }

  if (data->boolVariables.algebraics_old2) {
    free(data->boolVariables.algebraics_old2);
    data->boolVariables.algebraics_old2 = 0;
  }

  if (data->realAlias) {
    free(data->realAlias);
    data->realAlias = 0;
  }

  if (data->intVariables.alias) {
    free(data->intVariables.alias);
    data->intVariables.alias = 0;
  }

  if (data->boolVariables.alias) {
    free(data->boolVariables.alias);
    data->boolVariables.alias = 0;
  }

  if (data->stringVariables.alias) {
    free(data->stringVariables.alias);
    data->stringVariables.alias = 0;
  }

  if (data->jacobianVars) {
    free(data->jacobianVars);
    data->jacobianVars = 0;
  }

  if (data->initialResiduals){
    free(data->initialResiduals);
    data->initialResiduals = 0;
  }
  if (data->extObjs) {
    free(data->extObjs);
    data->extObjs = 0;
  }
  if (data->rawSampleExps) {
    free(data->rawSampleExps);
    data->rawSampleExps = 0;
  }
  /* adrpo: 2010-12-17 THIS IS WRONG as WE DO NOT ALLOCATE THIS in function initializeDataStruc!
  if(flags & RAWSAMPLES && data->sampleTimes) {
    free(data->sampleTimes);
    data->sampleTimes = 0;
  }
  */
}


int input_function()
{
  return 0;
}

int output_function()
{
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_sampleInit()
{
}

int function_updateSample()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

extern int const numDelayExpressionIndex = 0;
int function_storeDelayed()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int initial_function()
{


  
  return 0;
}

int initial_residual()
{
  int i = 0;
  state mem_state;
  modelica_real tmp1012;
  modelica_real tmp1013;
  
  mem_state = get_memory_state();
  tmp1012 = pre($Py);
  localData->initialResiduals[i++] = ($Py - tmp1012);
  if (sim_verbose == LOG_RES_INIT) { printf(" Residual[%d] : y - pre(y) = %f\n",i,localData->initialResiduals[i-1]); }
  tmp1013 = pre($Px);
  localData->initialResiduals[i++] = ($Px - tmp1013);
  if (sim_verbose == LOG_RES_INIT) { printf(" Residual[%d] : x - pre(x) = %f\n",i,localData->initialResiduals[i-1]); }
  restore_memory_state(mem_state);
  
  return 0;
}

int bound_parameters()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int functionODE()
{
  state mem_state;
  
  mem_state = get_memory_state();
  $P$DER$Py = $Px; 
  $P$DER$Px = (-$Py); 
  restore_memory_state(mem_state);
  
  return 0;
}
#if defined(_OMC_ENABLE_INLINE)
int functionODE_inline()
{
  state mem_state;
  
  mem_state = get_memory_state();
  begin_inline();
  $P$DER$Py = $Px; 
  inline_integrate($P$DER$Py);
  $P$DER$Px = (-$Py); 
  inline_integrate($P$DER$Px);
  end_inline();
  restore_memory_state(mem_state);
  
  return 0;
}
#else
int functionODE_inline()
{
  return 0;
}
#endif

int functionODE_residual(double *t, double *x, double *xd, double *delta,
                    fortran_integer *ires, double *rpar, fortran_integer *ipar)
{
  double timeBackup;
  double* statesBackup;

  timeBackup = localData->timeValue;
  statesBackup = localData->states;

  localData->timeValue = *t;
  localData->states = x;
  functionODE();

  /* get the difference between the temp_xd(=localData->statesDerivatives)
     and xd(=statesDerivativesBackup) */
  for (int i=0; i < localData->nStates; i++) {
    delta[i] = localData->statesDerivatives[i] - xd[i];
  }

  localData->states = statesBackup;
  localData->timeValue = timeBackup;

  return 0;
}

/* for continuous time variables */
int functionAlgebraics()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

/* for continuous time variables */
int functionAliasEquations()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int functionDAE(int *needToIterate)
{
  state mem_state;
  initial_rettype tmp1014;
  modelica_boolean tmp1015;
  modelica_boolean tmp1016;
  change_rettype tmp1017;
  modelica_real tmp1018;
  *needToIterate = 0;
  inUpdate=initial()?0:1;
  
  mem_state = get_memory_state();
  $P$DER$Py = $Px; 
  $P$DER$Px = (-$Py); 
  /*#modelicaLine [TestExt.mo:9:1-11:9]*/
  tmp1014 = initial();
  localData->helpVars[3] = tmp1014;
  if (edge(localData->helpVars[3])) {
    /*#modelicaLine [TestExt.mo:10:2-10:8]*/
    #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_FN(Init_index);
    #endif
    _Init();
    #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_FN(Init_index);
    #endif
    /* NORETCALL */;
    /*#endModelicaLine*/
  }
  /*#endModelicaLine*/
  /*#modelicaLine [TestExt.mo:12:3-16:11]*/
  SAVEZEROCROSS(tmp1016, $Px, 0.0, 1,Greater,>);
  localData->helpVars[1] = tmp1016;
  SAVEZEROCROSS(tmp1015, $Px, 0.0, -1,LessEq,<=);
  localData->helpVars[2] = tmp1015;
  if (edge(localData->helpVars[1])) {
    /*#modelicaLine [TestExt.mo:13:5-13:11]*/
    $Ps = 1.0;
    /*#endModelicaLine*/
  }
  else if (edge(localData->helpVars[2])) {
    /*#modelicaLine [TestExt.mo:15:5-15:11]*/
    $Ps = 0.0;
    /*#endModelicaLine*/
  }
  /*#endModelicaLine*/
  /*#modelicaLine [TestExt.mo:18:3-20:11]*/
  tmp1017 = change($Ps);
  localData->helpVars[0] = tmp1017;
  if (edge(localData->helpVars[0])) {
    /*#modelicaLine [TestExt.mo:19:4-19:24]*/
    tmp1018 = pre($Ps);
    #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_FN(Print_index);
    #endif
    _Print($Ps, tmp1018, time);
    #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_FN(Print_index);
    #endif
    /* NORETCALL */;
    /*#endModelicaLine*/
  }
  /*#endModelicaLine*/
  restore_memory_state(mem_state);
  
  inUpdate=0;
  
  return 0;
}

int function_onlyZeroCrossings(double *gout,double *t)
{
  state mem_state;
  
  mem_state = get_memory_state();
  ZEROCROSSING(0, LessEq($Px, 0.0));
  ZEROCROSSING(1, Greater($Px, 0.0));
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges()
{
  int needToIterate = 0;

  if (change($Ps)) { if (sim_verbose >= LOG_EVENTS) { cout << "Discrete Var s : " << (modelica_real) pre($Ps) << " to " << (modelica_real) $Ps << endl;}  needToIterate=1; }
  
  return needToIterate;
}

/* for continuous time variables */
int checkForAsserts()
{

  
  return 0;
}

int functionJacA( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int functionJacB( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int functionJacC( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int functionJacD( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int linear_model_frame(string &out, string A, string B, string C, string D, string x_startvalues, string u_startvalues)
{
  string def_head("model linear_testZC\n  parameter Integer n = 2; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 0; // top-level outputs \n");
  
  string def_init_states("  parameter Real x0[2] = {");
  string def_init_states_end("};\n");
  
  string def_init_inputs("  parameter Real u0[0] = {");
  string def_init_inputs_end("};\n");
  
  string def_vectorx("  Real x[2](start=x0);\n");
  string def_vectoru("  input Real u[0];\n");
  string def_vectory("  output Real y[0];\n");

  string def_matrixA_start("  parameter Real A[2,2] = [");
  string def_matrixA_end("];\n");
  string def_matrixB_start("  parameter Real B[2,0] = zeros(2,0);\n");
  string def_matrixB_end("");
  string def_matrixC_start("  parameter Real C[0,2] = zeros(0,2);\n");
  string def_matrixC_end("");
  string def_matrixD_start("  parameter Real D[0,0] = zeros(0,0);\n");
  string def_matrixD_end("");
  
  string def_Variable("\n  Real x_Px = x[1];\n  Real x_Py = x[2];\n      \n");
  
  string def_tail("equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_testZC;\n");
  
  out += def_head.data();
  out += def_init_states.data();
  out += x_startvalues.data();
  out += def_init_states_end.data();
  out += def_init_inputs.data();
  out += u_startvalues.data();
  out += def_init_inputs_end.data();
  out += def_matrixA_start.data();
  out += A.data();
  out += def_matrixA_end.data();
  out += def_matrixB_start.data();
  out += B.data();
  out += def_matrixB_end.data();
  out += def_matrixC_start.data();
  out += C.data();
  out += def_matrixC_end.data();
  out += def_matrixD_start.data();
  out += D.data();
  out += def_matrixD_end.data();
  out += def_vectorx.data();
  out += def_vectoru.data();
  out += def_vectory.data();
  out += def_Variable.data();
  out += def_tail.data();
  return 0;
}



