// Simulation code for Test generated by the OpenModelica Compiler 1.7.0 (r8719).

#include "modelica.h"
#include "assert.h"
#include "string.h"
#include "simulation_runtime.h"

#include "Test_functions.h"

#include "Test_functions.cpp"
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif
#define NHELP 0
#define NG 0 // number of zero crossings
#define NG_SAM 0 // number of zero crossings that are samples
#define NX 1  // number of states
#define NY 0  // number of real variables
#define NA 0  // number of alias variables
#define NP 2 // number of parameters
#define NO 0 // number of outputvar on topmodel
#define NI 0 // number of inputvar on topmodel
#define NR 1 // number of residuals for initialialization function
#define NEXT 0 // number of external objects
#define NFUNC 0 // number of functions used by the simulation
#define MAXORD 5
#define NYSTR 0 // number of alg. string variables
#define NASTR 0 // number of alias string variables
#define NPSTR 0 // number of alg. string variables
#define NYINT 0 // number of alg. int variables
#define NAINT 0 // number of alias int variables
#define NPINT 0 // number of alg. int variables
#define NYBOOL 0 // number of alg. bool variables
#define NABOOL 0 // number of alias bool variables
#define NPBOOL 0 // number of alg. bool variables
#define NJACVARS 0 // number of jacobian variables

static DATA* localData = 0;
#define time localData->timeValue
#define $P$old$Ptime localData->oldTime
#define $P$current_step_size globalData->current_stepsize

#ifndef _OMC_QSS
extern "C" { // adrpo: this is needed for Visual C++ compilation to work!
  const char *model_name="Test";
  const char *model_fileprefix="Test";
  const char *model_dir="";
}
#endif

// we need to access the inline define that we compiled the simulation with
// from the simulation runtime.
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;

const struct omc_varInfo state_names[1] = {
  {1000,"x","",{"TestFile.mo",2,2,2,25,false}}
};
#define $Px__varInfo state_names[0]
const struct omc_varInfo derivative_names[1] = {
  {1001,"der(x)","",{"TestFile.mo",2,2,2,25,false}}
};
#define $P$DER$Px__varInfo derivative_names[0]
const struct omc_varInfo algvars_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo param_names[2] = {
  {1002,"a","",{"TestFile.mo",3,2,3,23,false}},
  {1003,"x_start","",{"TestFile.mo",4,2,4,28,false}}
};
#define $Pa__varInfo param_names[0]
#define $Px_start__varInfo param_names[1]
const struct omc_varInfo alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo int_alg_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo int_param_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo int_alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo bool_alg_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo bool_param_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo bool_alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo string_alg_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo string_param_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo string_alias_names[1] = {{-1,"","",omc_dummyFileInfo}};
const struct omc_varInfo jacobian_names[1] = {{-1,"","",omc_dummyFileInfo}};
struct omc_functionInfo function_names[1] = {{-1,"",omc_dummyFileInfo}};

#define $Px localData->states[0]
#define $P$old$Px localData->states_old[0]
#define $P$old2$Px localData->states_old2[0]
#define $P$DER$Px localData->statesDerivatives[0]
#define $P$old$P$DER$Px localData->statesDerivatives_old[0]
#define $P$old2$P$DER$Px localData->statesDerivatives_old2[0]
#define $Pa localData->parameters[0]
#define $P$old$Pa localData->parameters_old[0]
#define $P$old2$Pa localData->parameters_old2[0]
#define $Px_start localData->parameters[1]
#define $P$old$Px_start localData->parameters_old[1]
#define $P$old2$Px_start localData->parameters_old2[1]

void init_Alias(DATA* data)
{
  sim_DATA_REAL_ALIAS omc__realAlias[1] = {{0,false,-1}};
  sim_DATA_INT_ALIAS omc__intAlias[1] = {{0,false,-1}};
  sim_DATA_BOOL_ALIAS omc__boolAlias[1] = {{0,false,-1}};
  sim_DATA_STRING_ALIAS omc__stringAlias[1] = {{0,false,-1}};
if (data->nAlias)
  memcpy(data->realAlias,omc__realAlias,sizeof(DATA_REAL_ALIAS)*data->nAlias);
if (data->intVariables.nAlias)
  memcpy(data->intVariables.alias,omc__intAlias,sizeof(DATA_INT_ALIAS)*data->intVariables.nAlias);
if (data->boolVariables.nAlias)
  memcpy(data->boolVariables.alias,omc__boolAlias,sizeof(DATA_BOOL_ALIAS)*data->boolVariables.nAlias);
if (data->stringVariables.nAlias)
  memcpy(data->stringVariables.alias,omc__stringAlias,sizeof(DATA_STRING_ALIAS)*data->stringVariables.nAlias);
};

static char init_fixed[NX+NX+NY+NYINT+NYBOOL+NP+NPINT+NPBOOL] = {
  1 /* x */,
  1 /* der(x) */,
  1 /* a */,
  1 /* x_start */
};

char var_attr[NX+NY+NYINT+NYBOOL+NYSTR+NP+NPINT+NPBOOL+NPSTR] = {
  1+0 /* x */,
  1+0 /* a */,
  1+0 /* x_start */
};

const int nEquation = 2;
const struct omc_equationInfo equation_info[2] = {
  {1004,"SES_ALGORITHM 0",0,NULL},
  {1005,"SES_SIMPLE_ASSIGN 1",1,&$P$DER$Px__varInfo}
};
const int n_omc_equationInfo_reverse_prof_index = 0;
const int omc_equationInfo_reverse_prof_index[] = {
  
};

const char* getNameReal(double* ptr)
{
  if (&$Px == ptr) return state_names[0].name;
  if (&$P$DER$Px == ptr) return derivative_names[0].name;
  if (&$Pa == ptr) return param_names[0].name;
  if (&$Px_start == ptr) return param_names[1].name;
  return "";
}

const char* getNameInt(modelica_integer* ptr)
{
  return "";
}

const char* getNameBool(modelica_boolean* ptr)
{
  return "";
}

const char* getNameString(const char** ptr)
{
  return "";
}

void setLocalData(DATA* data)
{
  localData = data;
  init_Alias(data);
}

DATA* initializeDataStruc()
{
  DATA* returnData = (DATA*)malloc(sizeof(DATA));

  if(!returnData) //error check
    return 0;

  memset(returnData,0,sizeof(DATA));
  returnData->nStates = NX;
  returnData->nAlgebraic = NY;
  returnData->nAlias = NA;
  returnData->nParameters = NP;
  returnData->nInputVars = NI;
  returnData->nOutputVars = NO;
  returnData->nFunctions = NFUNC;
  returnData->nEquations = nEquation;
  returnData->nProfileBlocks = n_omc_equationInfo_reverse_prof_index;
  returnData->nZeroCrossing = NG;
  returnData->nRawSamples = NG_SAM;
  returnData->nInitialResiduals = NR;
  returnData->nHelpVars = NHELP;
  returnData->stringVariables.nParameters = NPSTR;
  returnData->stringVariables.nAlgebraic = NYSTR;
  returnData->stringVariables.nAlias = NASTR;
  returnData->intVariables.nParameters = NPINT;
  returnData->intVariables.nAlgebraic = NYINT;
  returnData->intVariables.nAlias = NAINT;
  returnData->boolVariables.nParameters = NPBOOL;
  returnData->boolVariables.nAlgebraic = NYBOOL;
  returnData->boolVariables.nAlias = NABOOL;
  returnData->nJacobianvars = NJACVARS;

  if (returnData->nStates) {
    returnData->states = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nStates);
    returnData->states_old = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->states_old2 = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->states&&returnData->states_old&&returnData->states_old2);
    memset(returnData->states,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesFilterOutput,0,sizeof(modelica_boolean)*returnData->nStates);
    memset(returnData->states_old,0,sizeof(double)*returnData->nStates);
    memset(returnData->states_old2,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->states = 0;
    returnData->statesFilterOutput = 0;
    returnData->states_old = 0;
    returnData->states_old2 = 0;
  }

  if (returnData->nStates) {
    returnData->statesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesDerivativesFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nStates);
    returnData->statesDerivatives_old = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesDerivatives_old2 = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->statesDerivativesBackup = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->statesDerivatives&&returnData->statesDerivatives_old&&returnData->statesDerivatives_old2&&returnData->statesDerivativesBackup);
    memset(returnData->statesDerivatives,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesDerivativesFilterOutput,0,sizeof(modelica_boolean)*returnData->nStates);
    memset(returnData->statesDerivatives_old,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesDerivatives_old2,0,sizeof(double)*returnData->nStates);
    memset(returnData->statesDerivativesBackup,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->statesDerivatives = 0;
    returnData->statesDerivativesFilterOutput = 0;
    returnData->statesDerivatives_old = 0;
    returnData->statesDerivatives_old2 = 0;
    returnData->statesDerivativesBackup = 0;
  }

  if (returnData->nHelpVars) {
    returnData->helpVars = (double*) malloc(sizeof(double)*returnData->nHelpVars);
    assert(returnData->helpVars);
    memset(returnData->helpVars,0,sizeof(double)*returnData->nHelpVars);
  } else {
    returnData->helpVars = 0;
  }

  if (returnData->nAlgebraic) {
    returnData->algebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->algebraicsFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nAlgebraic);
    returnData->algebraics_old = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->algebraics_old2 = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    assert(returnData->algebraics&&returnData->algebraics_old&&returnData->algebraics_old2);
    memset(returnData->algebraics,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->algebraicsFilterOutput,0,sizeof(modelica_boolean)*returnData->nAlgebraic);
    memset(returnData->algebraics_old,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->algebraics_old2,0,sizeof(double)*returnData->nAlgebraic);
  } else {
    returnData->algebraics = 0;
    returnData->algebraicsFilterOutput = 0;
    returnData->algebraics_old = 0;
    returnData->algebraics_old2 = 0;
  }

  if (returnData->stringVariables.nAlgebraic) {
    returnData->stringVariables.algebraics = (const char**)malloc(sizeof(char*)*returnData->stringVariables.nAlgebraic);
    assert(returnData->stringVariables.algebraics);
    memset(returnData->stringVariables.algebraics,0,sizeof(char*)*returnData->stringVariables.nAlgebraic);
  } else {
    returnData->stringVariables.algebraics=0;
  }

  if (returnData->intVariables.nAlgebraic) {
    returnData->intVariables.algebraics = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    returnData->intVariables.algebraicsFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->intVariables.nAlgebraic);
    returnData->intVariables.algebraics_old = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    returnData->intVariables.algebraics_old2 = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    assert(returnData->intVariables.algebraics&&returnData->intVariables.algebraics_old&&returnData->intVariables.algebraics_old2);
    memset(returnData->intVariables.algebraics,0,sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    memset(returnData->intVariables.algebraicsFilterOutput,0,sizeof(modelica_boolean)*returnData->intVariables.nAlgebraic);
    memset(returnData->intVariables.algebraics_old,0,sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
    memset(returnData->intVariables.algebraics_old2,0,sizeof(modelica_integer)*returnData->intVariables.nAlgebraic);
  } else {
    returnData->intVariables.algebraics=0;
    returnData->intVariables.algebraicsFilterOutput=0;
    returnData->intVariables.algebraics_old = 0;
    returnData->intVariables.algebraics_old2 = 0;
  }

  if (returnData->boolVariables.nAlgebraic) {
    returnData->boolVariables.algebraics = (modelica_boolean*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    returnData->boolVariables.algebraicsFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    returnData->boolVariables.algebraics_old = (signed char*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    returnData->boolVariables.algebraics_old2 = (signed char*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    assert(returnData->boolVariables.algebraics&&returnData->boolVariables.algebraics_old&&returnData->boolVariables.algebraics_old2);
    memset(returnData->boolVariables.algebraics,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    memset(returnData->boolVariables.algebraicsFilterOutput,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    memset(returnData->boolVariables.algebraics_old,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
    memset(returnData->boolVariables.algebraics_old2,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlgebraic);
  } else {
    returnData->boolVariables.algebraics=0;
    returnData->boolVariables.algebraicsFilterOutput=0;
    returnData->boolVariables.algebraics_old = 0;
    returnData->boolVariables.algebraics_old2 = 0;
  }

  if (returnData->nParameters) {
    returnData->parameters = (double*) malloc(sizeof(double)*returnData->nParameters);
    assert(returnData->parameters);
    memset(returnData->parameters,0,sizeof(double)*returnData->nParameters);
  } else {
    returnData->parameters = 0;
  }

  if (returnData->stringVariables.nParameters) {
    returnData->stringVariables.parameters = (const char**)malloc(sizeof(char*)*returnData->stringVariables.nParameters);
      assert(returnData->stringVariables.parameters);
      memset(returnData->stringVariables.parameters,0,sizeof(char*)*returnData->stringVariables.nParameters);
  } else {
      returnData->stringVariables.parameters=0;
  }

  if (returnData->intVariables.nParameters) {
    returnData->intVariables.parameters = (modelica_integer*)malloc(sizeof(modelica_integer)*returnData->intVariables.nParameters);
      assert(returnData->intVariables.parameters);
      memset(returnData->intVariables.parameters,0,sizeof(modelica_integer)*returnData->intVariables.nParameters);
  } else {
      returnData->intVariables.parameters=0;
  }

  if (returnData->boolVariables.nParameters) {
    returnData->boolVariables.parameters = (modelica_boolean*)malloc(sizeof(modelica_boolean)*returnData->boolVariables.nParameters);
      assert(returnData->boolVariables.parameters);
      memset(returnData->boolVariables.parameters,0,sizeof(modelica_boolean)*returnData->boolVariables.nParameters);
  } else {
      returnData->boolVariables.parameters=0;
  }

  if (returnData->nOutputVars) {
    returnData->outputVars = (double*) malloc(sizeof(double)*returnData->nOutputVars);
    assert(returnData->outputVars);
    memset(returnData->outputVars,0,sizeof(double)*returnData->nOutputVars);
  } else {
    returnData->outputVars = 0;
  }

  if (returnData->nInputVars) {
    returnData->inputVars = (double*) malloc(sizeof(double)*returnData->nInputVars);
    assert(returnData->inputVars);
    memset(returnData->inputVars,0,sizeof(double)*returnData->nInputVars);
  } else {
    returnData->inputVars = 0;
  }

  if (returnData->nAlias) {
    returnData->realAlias = (DATA_REAL_ALIAS*) malloc(sizeof(DATA_REAL_ALIAS)*returnData->nAlias);
    assert(returnData->realAlias);
    returnData->aliasFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->nAlias);
    assert(returnData->aliasFilterOutput);
    memset(returnData->realAlias,0,sizeof(DATA_REAL_ALIAS)*returnData->nAlias);
    memset(returnData->aliasFilterOutput,0,sizeof(modelica_boolean)*returnData->nAlias);
  } else {
    returnData->realAlias = 0;
    returnData->aliasFilterOutput = 0;
  }

  if (returnData->intVariables.nAlias) {
    returnData->intVariables.alias = (sim_DATA_INT_ALIAS*) malloc(sizeof(sim_DATA_INT_ALIAS)*returnData->intVariables.nAlias);
    assert(returnData->intVariables.alias);
    returnData->intVariables.aliasFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->intVariables.nAlias);
    assert(returnData->intVariables.aliasFilterOutput);
    memset(returnData->intVariables.alias,0,sizeof(sim_DATA_INT_ALIAS)*returnData->intVariables.nAlias);
    memset(returnData->intVariables.aliasFilterOutput,0,sizeof(modelica_boolean)*returnData->intVariables.nAlias);
  } else {
    returnData->intVariables.alias = 0;
    returnData->intVariables.aliasFilterOutput=0;
  }

  if (returnData->boolVariables.nAlias) {
    returnData->boolVariables.alias = (DATA_BOOL_ALIAS*) malloc(sizeof(DATA_BOOL_ALIAS)*returnData->boolVariables.nAlias);
    assert(returnData->boolVariables.alias);
    returnData->boolVariables.aliasFilterOutput = (modelica_boolean*) malloc(sizeof(modelica_boolean)*returnData->boolVariables.nAlias);
    assert(returnData->boolVariables.aliasFilterOutput);
    memset(returnData->boolVariables.alias,0,sizeof(DATA_BOOL_ALIAS)*returnData->boolVariables.nAlias);
    memset(returnData->boolVariables.aliasFilterOutput,0,sizeof(modelica_boolean)*returnData->boolVariables.nAlias);
  } else {
    returnData->boolVariables.alias = 0;
    returnData->boolVariables.aliasFilterOutput=0;
  }

  if (returnData->stringVariables.nAlias) {
    returnData->stringVariables.alias = (DATA_STRING_ALIAS*) malloc(sizeof(DATA_STRING_ALIAS)*returnData->stringVariables.nAlias);
    assert(returnData->stringVariables.alias);
    memset(returnData->stringVariables.alias,0,sizeof(DATA_STRING_ALIAS)*returnData->stringVariables.nAlias);
  } else {
    returnData->stringVariables.alias = 0;
  }

  if (returnData->nJacobianvars) {
    returnData->jacobianVars = (double*) malloc(sizeof(double)*returnData->nJacobianvars);
    assert(returnData->jacobianVars);
    memset(returnData->jacobianVars,0,sizeof(double)*returnData->nJacobianvars);
  } else {
    returnData->jacobianVars = 0;
  }

  if (returnData->nInitialResiduals) {
    returnData->initialResiduals = (double*) malloc(sizeof(double)*returnData->nInitialResiduals);
    assert(returnData->initialResiduals);
    memset(returnData->initialResiduals,0,sizeof(double)*returnData->nInitialResiduals);
  } else {
    returnData->initialResiduals = 0;
  }

  returnData->initFixed = init_fixed;
  returnData->var_attr = var_attr;
  returnData->modelName = model_name;
  returnData->modelFilePrefix = model_fileprefix;
  returnData->statesNames = state_names;
  returnData->stateDerivativesNames = derivative_names;
  returnData->algebraicsNames = algvars_names;
  returnData->int_alg_names = int_alg_names;
  returnData->bool_alg_names = bool_alg_names;
  returnData->string_alg_names = string_alg_names;
  returnData->parametersNames = param_names;
  returnData->int_param_names = int_param_names;
  returnData->bool_param_names = bool_param_names;
  returnData->string_param_names = string_param_names;
  returnData->alias_names = alias_names;
  returnData->int_alias_names = int_alias_names;
  returnData->bool_alias_names = bool_alias_names;
  returnData->string_alias_names = string_alias_names;
  returnData->jacobian_names = jacobian_names;
  returnData->functionNames = function_names;
  returnData->equationInfo = equation_info;
  returnData->equationInfo_reverse_prof_index = omc_equationInfo_reverse_prof_index;

  if (returnData->nRawSamples) {
    returnData->rawSampleExps = (sample_raw_time*) malloc(sizeof(sample_raw_time)*returnData->nRawSamples);
    assert(returnData->rawSampleExps);
    memset(returnData->rawSampleExps,0,sizeof(sample_raw_time)*returnData->nRawSamples);
  } else {
    returnData->rawSampleExps = 0;
  }

  if (NEXT) {
    returnData->extObjs = (void**)malloc(sizeof(void*)*NEXT);
    if (!returnData->extObjs) {
      printf("error allocating external objects\n");
      exit(-2);
    }
    memset(returnData->extObjs,0,sizeof(void*)*NEXT);
  } else {
    returnData->extObjs = 0;
  }

  return returnData;
}


/* Has to be performed after _init.txt file has been read */
void callExternalObjectConstructors(DATA* localData) {
}


void deInitializeDataStruc(DATA* data)
{
  if(!data)
    return;

  if (data->states) {
    free(data->states);
    data->states = 0;
  }

  if (data->states_old) {
    free(data->states_old);
    data->states_old = 0;
  }

  if (data->states_old2) {
    free(data->states_old2);
    data->states_old2 = 0;
  }

  if (data->statesDerivatives) {
    free(data->statesDerivatives);
    data->statesDerivatives = 0;
  }

  if (data->statesDerivatives_old) {
    free(data->statesDerivatives_old);
    data->statesDerivatives_old = 0;
  }

  if (data->statesDerivatives_old2) {
    free(data->statesDerivatives_old2);
    data->statesDerivatives_old2 = 0;
  }

  if (data->algebraics) {
    free(data->algebraics);
    data->algebraics = 0;
  }

  if (data->algebraics_old) {
    free(data->algebraics_old);
    data->algebraics_old = 0;
  }

  if (data->algebraics_old2) {
    free(data->algebraics_old2);
    data->algebraics_old2 = 0;
  }

  if (data->parameters) {
    free(data->parameters);
    data->parameters = 0;
  }

  if (data->inputVars) {
    free(data->inputVars);
    data->inputVars = 0;
  }

  if (data->outputVars) {
    free(data->outputVars);
    data->outputVars = 0;
  }

  if (data->intVariables.algebraics) {
    free(data->intVariables.algebraics);
    data->intVariables.algebraics = 0;
  }

  if (data->intVariables.algebraics_old) {
    free(data->intVariables.algebraics_old);
    data->intVariables.algebraics_old = 0;
  }

  if (data->intVariables.algebraics_old2) {
    free(data->intVariables.algebraics_old2);
    data->intVariables.algebraics_old2 = 0;
  }

  if (data->boolVariables.algebraics) {
    free(data->boolVariables.algebraics);
    data->boolVariables.algebraics = 0;
  }

  if (data->boolVariables.algebraics_old) {
    free(data->boolVariables.algebraics_old);
    data->boolVariables.algebraics_old = 0;
  }

  if (data->boolVariables.algebraics_old2) {
    free(data->boolVariables.algebraics_old2);
    data->boolVariables.algebraics_old2 = 0;
  }

  if (data->realAlias) {
    free(data->realAlias);
    data->realAlias = 0;
  }

  if (data->intVariables.alias) {
    free(data->intVariables.alias);
    data->intVariables.alias = 0;
  }

  if (data->boolVariables.alias) {
    free(data->boolVariables.alias);
    data->boolVariables.alias = 0;
  }

  if (data->stringVariables.alias) {
    free(data->stringVariables.alias);
    data->stringVariables.alias = 0;
  }

  if (data->jacobianVars) {
    free(data->jacobianVars);
    data->jacobianVars = 0;
  }

  if (data->initialResiduals){
    free(data->initialResiduals);
    data->initialResiduals = 0;
  }
  if (data->extObjs) {
    free(data->extObjs);
    data->extObjs = 0;
  }
  if (data->rawSampleExps) {
    free(data->rawSampleExps);
    data->rawSampleExps = 0;
  }
  /* adrpo: 2010-12-17 THIS IS WRONG as WE DO NOT ALLOCATE THIS in function initializeDataStruc!
  if(flags & RAWSAMPLES && data->sampleTimes) {
    free(data->sampleTimes);
    data->sampleTimes = 0;
  }
  */
}


int input_function()
{
  return 0;
}

int output_function()
{
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_sampleInit()
{
}

int function_updateSample()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

extern int const numDelayExpressionIndex = 0;
int function_storeDelayed()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int initial_function()
{

  $Px = $Px_start; 

  if (sim_verbose >= LOG_INIT) { printf("Setting variable start value: %s(start=%f)\n", "$Px", (double) $Px); }
  
  return 0;
}

int initial_residual()
{
  int i = 0;
  state mem_state;
  modelica_real tmp1006;
  
  mem_state = get_memory_state();
  tmp1006 = pre($Px);
  localData->initialResiduals[i++] = ($Px - tmp1006);
  if (sim_verbose == LOG_RES_INIT) { printf(" Residual[%d] : x - pre(x) = %f\n",i,localData->initialResiduals[i-1]); }
  restore_memory_state(mem_state);
  
  return 0;
}

int bound_parameters()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int functionODE()
{
  state mem_state;
  
  mem_state = get_memory_state();
  $P$DER$Px = ($Pa * $Px); 
  restore_memory_state(mem_state);
  
  return 0;
}
#if defined(_OMC_ENABLE_INLINE)
int functionODE_inline()
{
  state mem_state;
  
  mem_state = get_memory_state();
  begin_inline();
  $P$DER$Px = ($Pa * $Px); 
  inline_integrate($P$DER$Px);
  end_inline();
  restore_memory_state(mem_state);
  
  return 0;
}
#else
int functionODE_inline()
{
  return 0;
}
#endif

int functionODE_residual(double *t, double *x, double *xd, double *delta,
                    fortran_integer *ires, double *rpar, fortran_integer *ipar)
{
  double timeBackup;
  double* statesBackup;

  timeBackup = localData->timeValue;
  statesBackup = localData->states;

  localData->timeValue = *t;
  localData->states = x;
  functionODE();

  /* get the difference between the temp_xd(=localData->statesDerivatives)
     and xd(=statesDerivativesBackup) */
  for (int i=0; i < localData->nStates; i++) {
    delta[i] = localData->statesDerivatives[i] - xd[i];
  }

  localData->states = statesBackup;
  localData->timeValue = timeBackup;

  return 0;
}

/* for continuous time variables */
int functionAlgebraics()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

/* for continuous time variables */
int functionAliasEquations()
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int functionDAE(int *needToIterate)
{
  state mem_state;
  *needToIterate = 0;
  inUpdate=initial()?0:1;
  
  mem_state = get_memory_state();
  $P$DER$Px = ($Pa * $Px); 
  restore_memory_state(mem_state);
  
  inUpdate=0;
  
  return 0;
}

int function_onlyZeroCrossings(double *gout,double *t)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges()
{
  int needToIterate = 0;

  
  return needToIterate;
}

/* for continuous time variables */
int checkForAsserts()
{

  
  return 0;
}

int functionJacA( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int functionJacB( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int functionJacC( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int functionJacD( double *jac)
{
  state mem_state;


  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


int linear_model_frame(string &out, string A, string B, string C, string D, string x_startvalues, string u_startvalues)
{
  string def_head("model linear_Test\n  parameter Integer n = 1; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 0; // top-level outputs \n");
  
  string def_init_states("  parameter Real x0[1] = {");
  string def_init_states_end("};\n");
  
  string def_init_inputs("  parameter Real u0[0] = {");
  string def_init_inputs_end("};\n");
  
  string def_vectorx("  Real x[1](start=x0);\n");
  string def_vectoru("  input Real u[0];\n");
  string def_vectory("  output Real y[0];\n");

  string def_matrixA_start("  parameter Real A[1,1] = [");
  string def_matrixA_end("];\n");
  string def_matrixB_start("  parameter Real B[1,0] = zeros(1,0);\n");
  string def_matrixB_end("");
  string def_matrixC_start("  parameter Real C[0,1] = zeros(0,1);\n");
  string def_matrixC_end("");
  string def_matrixD_start("  parameter Real D[0,0] = zeros(0,0);\n");
  string def_matrixD_end("");
  
  string def_Variable("\n  Real x_Px = x[1];\n      \n");
  
  string def_tail("equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_Test;\n");
  
  out += def_head.data();
  out += def_init_states.data();
  out += x_startvalues.data();
  out += def_init_states_end.data();
  out += def_init_inputs.data();
  out += u_startvalues.data();
  out += def_init_inputs_end.data();
  out += def_matrixA_start.data();
  out += A.data();
  out += def_matrixA_end.data();
  out += def_matrixB_start.data();
  out += B.data();
  out += def_matrixB_end.data();
  out += def_matrixC_start.data();
  out += C.data();
  out += def_matrixC_end.data();
  out += def_matrixD_start.data();
  out += D.data();
  out += def_matrixD_end.data();
  out += def_vectorx.data();
  out += def_vectoru.data();
  out += def_vectory.data();
  out += def_Variable.data();
  out += def_tail.data();
  return 0;
}



